### 01 作用域和闭包的关系

#### 01、前言

作用域和闭包在面试和工作中都是经常遇到的知识点，从概念的角度讲：

> 作用域本质是一套存储和访问变量的规则。
>
> 闭包本质是一个函数，不过是当前函数及其所在词法作用域的结合。

从概念上就可以看出，闭包离不开作用域，js里的作用域都是词法作用域。



#### 02、作用域和作用域链

在详细介绍两者关系之前，有必要介绍一下作用域的分类：

- 全局作用域
- 函数作用域
- 块作用域

关于每种作用域这里不做过多介绍。

作用域链指的是查找自由变量时，从当前作用域一层一层向上查找，如果没找到会直到全局作用域，这一层一层的关系叫做作用域链。



其实关于作用域，我最想说的是其**实现机制**，准备从**编译原理**的角度解释一下，其中涉及到了**编译器**和**js引擎**：

在《你不知道的JavaScript》中作者认为`js`是一门**编译语言**，传统编译语言的编译过程如下：

1. 词法分析：这个过程会将字符串分割为有意义的**代码块**，这些代码块称之为**词法单元**
2. 语法分析：这个过程会将**词法单元流**转换成一棵**抽象语法树**
3. 代码生成：将`AST`转化为可执行的代码

而`js`引擎中编译器做的事与上述类似，区别在于`JavaScript`的编译过程是在**执行前进行**的，而且并不会产生可移植的编译结果（比如xxx.exe）。

这里的执行前是有多前呢？可能就只有几微妙、或者更短的时间。如果从时间上还是理解不清楚，看下面的代码：

```js
for(i=0; i < 1000; i++){
    sum += i;
}
```

在编译型语言中sum += i部分在循环运行时已经编译成了机器码，机器码将直接运行一千次，这是很容易理解的。

但是在解释型语言中，如果不做优化，执行时会将sum += i转换（编译）一千次。这是因为这段代码要执行1000次，而上边说编译过程是在执行前进行的，每次编译器都会请求作用域进行`LHS`和`RHS`查询，所以也会编译1000次。

JavaScript引擎在这部分做了许多优化：

- 一是对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化），目的是提高编译后的执行效率。
- 二是对编译过程进行优化（如`JIT`，延迟编译或者重编译），目的是缩短编译过程，保证性能最佳。



#### 03、js引擎、编译器、作用域之间的关系

感觉这三者之间的关系类似"老板-秘书-员工"。

+ 老板-**引擎**：统筹全局，负责整个JS程序的编译及执行过程；

+ 秘书-**编译器**：把提前工作做好，负责语法分析及代码生成等工作；

+ 员工-**作用域**：干最累的活，老板、秘书发号施令：给我查一下当前有没有一个叫做`xxx`的变量，作用域立马得去干；秘书发话：如果没有改变量，你就声明一个。



一个具体的例子：

```js
var a = 2;
```

秘书(小刘)：小冯(员工)，我需要对a进行LHS查找，你见过么？

小冯(员工)：我这找到根都没看到啊，要不咱声明一个吧！

秘书(小刘)：好，建好了，那我生成代码了，老板，给你你要的代码。

老板(大姚)：效率挺快，咦，需要一个a啊，小冯，帮我LHS找一下有没有？

小冯(员工)： 好的老板，找到了，刘秘书已经帮忙声明了。

老板(大姚)：好的，那我对a赋值了。

老板(大姚)：小冯啊，我碰到一个console，需要RHS引用，查一下？

小冯(员工)： 找到了找到了，是个内置对象，给您。

老板(大姚)： 好的小冯，对了能在帮我确认一下a的RHS么？

小冯(员工)：确认好了，没变，拿去拿去（此时已经有些不耐烦了），他的值是2

老板(大姚)：行，我把2传递给log(..)



#### 04、作用域如何进行查找的

这就涉及到了`LHS`、`RHS`，这是作用域查询变量的两种方式，当变量出现在赋值操作的左侧时，就是`LHS`，出现在右侧时，就是`RHS`。

`LHS` 意味着 **变量赋值或写入内存，**强调的是写这个动作。

`RHS` 意味着 **变量查找或从内存中读取**，强调的是读这个动作。

单纯理解`LHS`和`RHS`没啥意义，需要结合实际代码运行去理解，比如上边的例子。



#### 05、词法作用域 vs 动态作用域

使用动态作用域的语言很少，比如Bash 脚本、Perl 等。

要对比这两者，首先要跳出`JavaScript`语言，先看一个例子

```js
var name = 'xiuyan';

function showName() {
    console.log(name);
}

function changeName() {
    var name = 'BigBear';
    showName();
}

changeName();
```



如果是词法作用域，运行结果会是`xiuyan`；

如果是动态作用域，运行结果会是`BigBear`;



所以，两者的区别如下：

- 词法作用域： 在代码书写的时候完成划分，作用域链沿着它**定义的位置**往外延伸
- 动态作用域： 在代码运行时完成划分，作用域链沿着它的**调用栈**往外延伸



#### 06、如何修改词法作用域（了解即可）

有两种方法修改词法作用域：`eval`和`with`，了解即可。



**eval 对作用域的修改**

```js
function showName(str) {
  eval(str)
  console.log(name)
}

var name = 'xiuyan'
var str = 'var name = "BigBear"'

showName(str) // 输出 BigBear
```



**with 对作用域的修改**

```js
function changeName(person) {
  with(person) {
    name = 'BigBear'
  }
}

var me = {
  name: 'xiuyan',
  career: 'coder',
  hobbies: ['coding', 'footbal']
}

var you = {
  career: 'product manager'
}

changeName(me)
changeName(you)
console.log(name) // 输出 'BigBear'
```



#### 07、闭包

如果上边的作用域已经看明白了，再去理解闭包就已经很容易了，回顾一下定义：

> 闭包本质是一个函数，不过是当前函数及其所在词法作用域的结合。



然后再来看一段代码：

```js
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
```

这是一个经典的面试题，主要考察三个点：

1. 闭包
2. 事件循环、宏任务
3. 将i值依次输出的解决方法

先看`setTimeout`里面的函数，根据作用域的知识，当前作用域没有变量 i ，往上找，这种对所在词法作用域中变量的引用，就形成了**闭包**。

最终的输出结果是6个5，这涉及到事件循环和宏任务，每次循环将`setTimeout`加入宏任务队列，等当前循环执行结束之后再去宏任务队列中依次执行，这时 i 值已经是5了。

然后面试官可能会问：如果想依次输出0到4，怎么解决？

+ 一种方法是使用ES6的let生成块级作用域
+ 另一种方法是ES5的IIFE(立即执行函数)



再看两道题：

```js
function test (){
    var num = []
    var i

    for (i = 0; i < 10; i++) {
        num[i] = function () {
            console.log(i)
        }
    }

    return num[9]
}

test()()
```

```js
ar test = (function() {
    var num = 0
    return () => {
        return num++
    }
}())

for (var i = 0; i < 10; i++) {
    test()
}

console.log(test())
```



最后两道面试真题：

```js
var a = 1;
function test(){
    a = 2;
    return function(){
        console.log(a);
    }
    var a = 3;
}
test()();
```

这题考到了变量提升，相当于:

```js
var a = 1;
function test(){
    var a = 2;
    return function(){
        console.log(a);
    }
    a = 3;
}
test()();
```



下面这道是我面试腾讯时遇到的真题：

```js
function foo(a,b){
  console.log(b);
  return {
    foo:function(c){
      return foo(c,a);
    }
  }
}

var func1=foo(0);
func1.foo(1);
func1.foo(2);
func1.foo(3);
var func2=foo(0).foo(1).foo(2).foo(3);
var func3=foo(0).foo(1);
func3.foo(2);
func3.foo(3);
```



#### 08、闭包的应用

这个就很多了，比如定时器，事件，模块私有变量，柯里化，偏函数，防抖函数等等。

