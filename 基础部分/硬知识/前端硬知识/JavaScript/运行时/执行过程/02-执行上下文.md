# 执行上下文

## js代码执行流程简单介绍
我们知道javascript是一门解释型语言，因为js代码的执行分为两个阶段：解释阶段和执行阶段。

在解释阶段，有词法分析和语法分析，词法分析是将代码分解为词元(token)，语法分析是将词元整理成抽象语法树(AST)，然后由解释器转换为字节码然后是机器码，计算机最终执行机器码。

在执行阶段，有预编译阶段和运行阶段，预编译阶段主要负责创建执行上下文，包括创建变量对象，创建作用域链和确定this指向，运行阶段则主要负责为变量赋值和代码执行。

执行上下文是代码**执行阶段**重要的一部分，本问主要从以下进行分析
+ [什么是执行上下文](#一、什么是执行上下文)

+ [执行上下文的生命周期](#二、执行上下文的生命周期)
  + [创建阶段](#创建阶段)
  + [执行阶段](#执行阶段)
  + [回收阶段](#回收阶段)

## 一、什么是执行上下文
执行上下文就是js代码被解析和执行时所在的环境，概念有点抽象，可以从上下文的分类来进行思考：

+ 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
+ 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
+ Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。

## 二、执行上下文的生命周期
执行上下文的生命周期包括三个阶段：创建阶段→执行阶段→回收阶段。

### 2.1.创建阶段
当函数被调用，但未执行其内部代码之前，即Creation阶段，js引擎会做以下几件事：
+ [创建变量对象](#创建变量对象)
+ [创建作用域链](#创建作用域链)
+ [确定this指向](#确定this指向)

*具体来说：*

+ 在全局执行上下文中，Creation阶段，js引擎将

  + 创建一个全局对象window
  + 设置变量和函数的存储空间，并提升函数声明和变量声明，内存中变量声明的默认值为"undefined"
  + 创建一个名为“this”的对象，指向window


+ 在函数执行上下文中，Creation阶段，js引擎会
  + 创建一个参数对象arguments
  + 设置变量和函数的存储空间，并提升函数声明和变量声明，内存中变量声明的默认值为"undefined"
  + 创建一个名为this的对象，具体执行有多种情况

#### 创建变量对象
在执行上下文中，除了创建对象之外，还进行了变量和函数的提升，this指向的确定，逐个来讲：
+ 函数和变量提升
  + 如果有形参，会先给形参赋值
  + 注意一个点就行了，就是函数和变量名字一样的时候，函数的优先级比变量高，因此变量的声明会被函数覆盖，但可以重新赋值
  + 私有作用域中的代码会从上往下执行


#### 创建作用域链
作用域分为全局作用域、函数作用域和块级作用域。作用域中的自由变量会从内部函数向外部函数一层一层查找，直到全局作用域为止，这一层层的关系就形成了作用域链。

这里要区别作用域和执行上下文：
+ （词法）作用域是在**解释阶段**生成的，即语法分析生成AST之后，便生成了作用域链，因为是在定义阶段就生成好了，所以后边不会改变
+ 执行上下文是在**执行阶段**生成的，这是动态的，一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。

#### 确定this指向

<div align=center>
  <img src="./imgs/this指向.png">
</div>



### 2.2.执行阶段
在执行一段代码时，JS 引擎会首先创建一个执行上下文栈

然后JS引擎会创建一个全局执行上下文，并push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。

如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。

还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。

最后，JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。

### 2.3.回收阶段
JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

一般来说，垃圾处理器有自己的回收策略。

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

V8引擎垃圾回收是通过新生代和老生代，新生代中使用了scanvenge算法进行快速的垃圾回收，老生代中使用了Mark-Sweep（标记清除） 和 Mark-Compact（标记整理）算法。

具体的垃圾回收和内存泄漏问题可以参考[这篇文章](https://cloud.tencent.com/developer/article/1462409)


