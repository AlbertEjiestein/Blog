# 从浏览器多进程到JS单线程的运行机制

这篇文章打算把浏览器这块的知识大体总结一下，主要按从大到小的范围梳理一下：

![image-20200724163138695](/Users/bytedance/Library/Application Support/typora-user-images/image-20200724163138695.png)

作为前端开发人员，接触最多的应该是后边两步，但是不得不说这两步主要是浏览器的一个进程完成的，当然也是最主要的进程--浏览器渲染进程，即浏览器内核（不用刻意去记这些名词，后边梳理完整个过程自然就明白了）。



## 1. 进程和线程

开始之前，首先得说一下进程和线程的概念。两者的关系已经是很清楚了，一个进程可以有多个线程，关键在于使用上。

示例形象描述：

```
- 进程是一个工厂，工厂有它的独立资源

- 工厂之间相互独立

- 线程是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人

- 工人之间共享空间
```

再看官方描述：

```
- 进程是cpu资源分配的最小单位

- 线程是cpu调度的最小单位
```



## 2. 浏览器多进程运作机制

![image-20200724162011472](/Users/bytedance/Library/Application Support/typora-user-images/image-20200724162011472.png)

首先需要知道的是浏览器是多进程的，我们每打开一个tab页，就多了一个（渲染）进程，如上图所示，当然一个tab对应一个进程不是绝对的，tab页面会有合并情况。另外，浏览器之所以可以运行，是因为系统分配了cpu和内存等资源。



### 2.1 浏览器的多进程

浏览器多进程主要有以下分类：

+ Browser进程：主进程，只有一个。作用有
  + 负责浏览器界面操作，比如前进、后退、查看等
  + 负责网络资源的管理下载等
  + 负责页面的管理，比如其他进程的创建和销毁
  + 负责绘制用户界面，render进程在内存中完成渲染、合成操作，然后由主进程绘制到界面上
+ GPU进程：只有一个，用于3D绘制
+ 插件进程：每一种插件对应一个进程，使用插件时才创建
+ Render进程：可以有多个，每个渲染进程可以有多个线程：
  + 页面渲染（GUI线程）
  + 脚本执行（js引擎线程）
  + 事件处理（事件触发线程）

https://segmentfault.com/a/1190000012925872

### 2.2 Browser进程和浏览器内核（Renderer进程）的通信过程

当我们在浏览器中输入一个url之后，浏览器会去请求资源并且渲染出页面，那这个过程在浏览器进程之间是如何分工协作的呢？

+ 首先Browser进程会发起获取资源的请求，因为这个进程是负责资源下载的，但是它不负责渲染，因此在获取到资源之后，便通过RendererHost接口传递给Render进程
+ Render进程通过Render接口获取到资源之后，传给GUI渲染线程，该线程负责的是解析HTML、CSS、构建DOM树以及排版和绘制。当然这个过程中可能会需要其他进程配合，比如解析HTML的时候遇到资源需要Browser进程去下载，3D渲染的时候需要GPU进程，以及执行脚本时需要js引擎操作DOM
+ 完成这些之后，还差绘制到屏幕，实际上Render进程中做的是渲染、合成操作，最后还需要Browser进程将合成的bitmap绘制到屏幕才算结束
+ 到现在，Browser和Renderer进程的通信算是完成了，至于后边的js操作，比如事件触发、定时器、发起异步请求等，就是其他线程的任务了



### 2.3 浏览器内核中的多线程

要明白浏览器渲染以及js运作机制的原理，必须要知道浏览器内核中的多线程有哪些。看下面：

+ **GUI渲染线程**

  + 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。

  + 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行

  + 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。

+ **js引擎线程**也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）

  + JS引擎线程负责解析Javascript脚本，运行代码。

  + JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序

  + 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

+ **事件触发线程**

  + 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）

  + 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中

  + 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理

  + 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

+ **定时器线程**
  + 传说中的`setInterval`与`setTimeout`所在线程
  + 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
  + 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
  + 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

+ **异步http请求线程**
  + 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求

  + 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。



既然**GUI渲染线程与JS引擎线程是互斥的**，那么js执行时间过长就会造成页面阻塞，针对计算密集型问题，js的解决方案是**WebWorker和SharedWorker**。区别如下：

WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享

- 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用

- 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。



## 3. 浏览器渲染过程



## 4. js运行机制

